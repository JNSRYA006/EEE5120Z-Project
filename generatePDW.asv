function PDW = generatePDW(PDWParams,TOA,AOA,Amp, Freq, PW,radarParams)

    % Check that scan mode is of correct type
    validScanModes = ["none","circular","sector","lock"];

    % Extract scanMode from all radari fields in radarParameters
    radarCells = struct2cell(radarParams);
    scanModes = string(cellfun(@(x) x.scanMode, radarCells, 'UniformOutput', false));

    if ~ismember(lower(scanModes),validScanModes)
        error('Invalid scanMode. Allowed values are: "none", "circular", "sector", "lock" [Non case-sensitive]');
    end

    TOA_range = calcRange(PDWParams.TOA.bits,PDWParams.TOA.resolution);
    % fprintf('Discrete Range (TOA):%f\n',TOA_range);
    % fprintf('Given Range: (TOA):%f\n',TOA_max-TOA_min);
    
    AOA_max = PDWParams.AOA.max;
    AOA_min = PDWParams.AOA.min;

    AOA_range = calcRange(PDWParams.AOA.bits,PDWParams.AOA.resolution);
    Amp_range = calcRange(PDWParams.Amp.bits,PDWParams.Amp.resolution);
    Freq_range = calcRange(PDWParams.Freq.bits,PDWParams.Freq.resolution);
    PW_range = calcRange(PDWParams.PW.bits,PDWParams.PW.resolution);
    % Check if input values are in the allowable range
    try
        % TOA
        if TOA < PDWParams.TOA.min || TOA > PDWParams.TOA.max
            error('TOA must be within the range %.0f to %.2f seconds',PDWParams.TOA.min,PDWParams.TOA.max);
        end
    catch ME
        error('TOA Error: %s\n', ME.message);
    end
    
    try
        % AOA
        if AOA < PDWParams.AOA.min || AOA > PDWParams.AOA.max
            error('AOA must be within the range %.0f to %.2f degrees',PDWParams.AOA.min,PDWParams.AOA.max);
        end
    catch ME
        error('AOA Error: %s\n', ME.message);
    end
    
    try
        % Amplitude
        % disp(Amp);
        if Amp < PDWParams.Amp.min || Amp > PDWParams.Amp.max
            error('Amplitude must be within the range %.2f to %.2f dB',PDWParams.Amp.min,PDWParams.Amp.max);
        end
    catch ME
        error('Amplitude Error: %s\n', ME.message);
    end
    
    try
        % Frequency
        if Freq < PDWParams.Freq.min || Freq > PDWParams.Freq.max
            error('Frequency must be within the range %.2f to %.2f GHz',PDWParams.Freq.min*1e-9,PDWParams.Freq.max*1e-9);
        end
    catch ME
        error('Frequency Error: %s\n', ME.message);
    end
    
    try
        % Pulse Width
        if PW < PDWParams.PW.min || PW > PDWParams.PW.max
            error('Pulse Width must be within the range %.2f to %.2f Âµs',PDWParams.PW.min*1e6, PDWParams.PW.max*1e6);
        end
    catch ME
        error('Pulse Width Error: %s\n', ME.message);
    end

    % Create the PDW structure by discretising the input parameters
    % Will be the closet value
    PDW.TOA = discretiseVal(TOA,PDWParams.TOA.min,PDWParams.TOA.resolution,TOA_range);
    PDW.AOA = discretiseVal(AOA,PDWParams.AOA.min,PDWParams.AOA.resolution,AOA_range);
    PDW.Amp = discretiseVal(Amp,PDWParams.Amp.min,PDWParams.Amp.resolution,Amp_range);
    PDW.Freq = discretiseVal(Freq,PDWParams.Freq.min,PDWParams.Freq.resolution,Freq_range);
    PDW.PW = discretiseVal(PW,PDWParams.PW.min,PDWParams.PW.resolution,PW_range);
end

function discretised = discretiseVal(value,min_val,resolution,range)
    norm_val = (value-min_val)/range;
    levels = range/resolution;
    discrete_level = round(norm_val*levels);
    discretised = min_val + discrete_level*resolution;
    % range = (2^bits -1)*resolution;
end

function range = calcRange(bits,resolution)
    range = (2^bits -1)*resolution;
end

function PDW_mainlobe = circularScan(PDWParams,radarParams,radarName)
    % Extract radar parameters
    AOA = radar.AOA;
    PRI = radar.PRI;
    beamwidth = radar.Beamwidth; 
    mainlobe = 2*beamwidth;
    scanPeriod = radar.scanPeriod; % s
    scanRate = 360/scanPeriod;
    sensitivity = -50; % dBm
    % observationWindow = 3; % s
    
    %% Calculate Tx Mainlobe
    
    % Num of pulses per beamwidth rotation
    disp('-----------------------------------------------');
    fprintf('Scan rate of Tx radar: %.0f deg/s\n',scanRate);
    t_beamwidth_rotation = beamwidth/scanRate; % Time for 3dB beamwidth to rotate through
    t_mainlobe_rotation = mainlobe/scanRate; % Time for mainlobe to rotate through full size
    fprintf('%.3f ms for rotation through %.2f deg (mainlobe)\n',t_mainlobe_rotation*1e3,mainlobe);
    pulse_beamwidth_rotation = floor(t_beamwidth_rotation/PRI); % Number of pulses emitted for 3dB beamwidth to rotate
    pulse_mainlobe_rotation = floor(t_mainlobe_rotation/PRI); % Number of pulses emitted for whole mainlobe to rotate
    fprintf('%.0f full pulses emitted in rotation through full mainlobe\n',pulse_mainlobe_rotation);
    disp('-----------------------------------------------');
    
    n = 100000;
    % Define the angle theta from 0 to 360 degrees
    theta = linspace(0, 360, n);
    % theta_mainlobe = theta;
    % theta_mainlobe(theta_mainlobe>mainlobe) = 0;
    theta_mainlobe = linspace(0,mainlobe,n);
    
    % Compute the function f(theta)
    amplitude = sin((theta_mainlobe*pi)/(2*beamwidth));
    
    % Compute the amplitude in dB
    amplitude_dB = 20*log10(amplitude)+(radar.peakAmp);
    
    % Find indices where amplitude is above sensitivity of ESM receiver
    above_sensitivity = find(amplitude_dB > sensitivity);
    
    % Update amplitude and theta arrays to match these indices
    amplitude_dB_above_sensitivity = amplitude_dB(above_sensitivity);
    theta_mainlobe_above_sensitivity = theta_mainlobe(above_sensitivity);
    
    % Find the angle at which the sensitivity is met
    theta_first_detection = theta_mainlobe_above_sensitivity(1);
    amplitude_first_detection = amplitude_dB_above_sensitivity(1);
    fprintf('First detection occurs at: %.4f degrees with an amplitude of %.4f dB.\n', ...
        theta_first_detection,amplitude_first_detection); % This will vary 
    % slightly based on the resolution of the theta linspace
    
    % Need to offset this first detection to occur at t = TOA (Based on Table
    % 2)
    % Fist detect per Table 2
    esm_first_detection = radar.TOA;
    
    % All scan time
    scan_time = linspace(0,scanPeriod,n);
    % Mainlobe scan time
    scan_time_mainlobe = linspace(0,t_mainlobe_rotation,n);
    t_boresight = (beamwidth/360)*scanPeriod;
    
    % Calculate shift so first intercept happens at esm_first_detection
    time_first_detection = scan_time_mainlobe(above_sensitivity(1));
    time_shift = esm_first_detection - time_first_detection;
    
    % Shift scan_time array
    scan_time_shift = scan_time + time_shift;
    scan_time_mainlobe_shift = scan_time_mainlobe + time_shift;
    
    % Calculate the number of pulses above the sensitivity threshold
    t_pulses_detected = scan_time_mainlobe(above_sensitivity(end))-scan_time_mainlobe(above_sensitivity(1));
    pulse_detection_rotation = floor(t_pulses_detected/PRI); % Number of pulses emitted for whole mainlobe to rotate
    
    % Calculate the time (indices as well) at which pulses occurs
    % Index of scan_time array
    %---------
    % Time
    pulses_mainlobe = zeros(2,pulse_detection_rotation);
    pulses_mainlobe_amp = zeros(1,pulse_detection_rotation);
    pulses_mainlobe_aoa = zeros(1,pulse_detection_rotation);
    pulses_mainlobe(1,1) = 1; % First pulse at first index
    pulses_mainlobe(2,1) = esm_first_detection; % First pulse at t = TOA
    % Find all PRI indices and associated time over scan in mainlobe
    for k = 2:pulse_detection_rotation
        % Calculate time for k-th pulse
        pulse_time = esm_first_detection +(k-1)*PRI;
        % Find closest index
        [~,closest_idx] = min(abs(scan_time_mainlobe_shift-pulse_time));
        pulses_mainlobe(1,k) = closest_idx;
        pulses_mainlobe(2,k) = scan_time_mainlobe_shift(closest_idx);
    end
    
    % Calculate associated Amp & AOA change based on TOA for each pulse
    for i=1:pulse_detection_rotation
        pulse_time = esm_first_detection +(i)*PRI;
        [~,closest_idx] = min(abs(scan_time_mainlobe_shift-pulse_time));
        pulses_mainlobe_aoa(i) = scanRate*pulses_mainlobe(2,i);
        pulses_mainlobe_amp(i) = amplitude_dB(closest_idx);
    end
    
    % Generate PDWs for all pulses in single mainlobe
    % PDW_mainlobe(pulse_detection_rotation) = struct();
    for detected_pulse = 1:pulse_detection_rotation
        PDW_mainlobe(detected_pulse) = generatePDW(PDWParameters,pulses_mainlobe(2,detected_pulse),pulses_mainlobe_aoa(detected_pulse),pulses_mainlobe_amp(detected_pulse),radar.Freq,radar.PW,radarParameters);
    end

end
    